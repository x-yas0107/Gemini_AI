/*
 * CH32V006 Tiny BASIC Interpreter v1.4 (Final Release)
 * * [Hardware Map]
 * - TX:  PD5 (Pin 2)
 * - RX:  PD6 (Pin 3)
 * - LED: PD0 (Pin 8)
 * - ADC: PA1 (Pin 5)
 */

#define USE_STDPERIPH_DRIVER
#include "debug.h"
#include "ch32v00x.h"
#include "ch32v00x_rcc.h"
#include "ch32v00x_gpio.h"
#include "ch32v00x_usart.h"
#include "ch32v00x_adc.h"
#include "ch32v00x_misc.h"
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>

#define PROG_SIZE 4096
#define RX_BUF_SIZE 64
#define VAR_COUNT 26

unsigned char program[PROG_SIZE];
int variables[VAR_COUNT];
unsigned char *txtpos;
jmp_buf error_jmp;

// --- Hardware Drivers ---
void Hardware_Init(void) {
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
    SystemCoreClockUpdate();
    Delay_Init();
    RCC_PB2PeriphClockCmd(RCC_PB2Periph_GPIOD | RCC_PB2Periph_GPIOA | RCC_PB2Periph_USART1 | RCC_PB2Periph_ADC1, ENABLE);

    GPIO_InitTypeDef GPIO_InitStructure = {0};
    USART_InitTypeDef USART_InitStructure = {0};

    // UART PD5/PD6
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_30MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOD, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOD, &GPIO_InitStructure);

    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_Init(USART1, &USART_InitStructure);
    USART_Cmd(USART1, ENABLE);

    // LED PD0
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_30MHz;
    GPIO_Init(GPIOD, &GPIO_InitStructure);

    // ADC PA1
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    RCC_ADCCLKConfig(RCC_PCLK2_Div8);
    ADC_InitTypeDef ADC_InitStructure = {0};
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    ADC_InitStructure.ADC_ScanConvMode = DISABLE;
    ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStructure.ADC_NbrOfChannel = 1;
    ADC_Init(ADC1, &ADC_InitStructure);
    ADC_Cmd(ADC1, ENABLE);
}

int Serial_Available(void) {
    return (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == SET);
}

char Serial_ReadChar(void) {
    while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
    return (char)USART_ReceiveData(USART1);
}

void LED_Set(int state) {
    GPIO_WriteBit(GPIOD, GPIO_Pin_0, state ? Bit_SET : Bit_RESET);
}

int ADC_Read(void) {
    ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_CyclesMode7);
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC));
    return ADC_GetConversionValue(ADC1);
}

// --- Interpreter Core ---
void error(char *msg) {
    printf("\r\nError: %s\r\n", msg);
    longjmp(error_jmp, 1);
}

void check_break(void) {
    if (Serial_Available()) {
        char c = (char)USART_ReceiveData(USART1);
        if (c == 3) error("Break"); // Ctrl+C
    }
}

char peek(void) { return *txtpos; }
void skip(void) { if (*txtpos) txtpos++; }
void ignore_blanks(void) { while (*txtpos <= ' ' && *txtpos != 0) txtpos++; }

void match(char c) {
    ignore_blanks();
    if (*txtpos == c) skip();
    else error("SynErr");
}

int expression(void);

int number(void) {
    int val = 0;
    ignore_blanks();
    if (!isdigit(*txtpos)) error("Num?");
    while (isdigit(*txtpos)) {
        val = val * 10 + (*txtpos - '0');
        txtpos++;
    }
    return val;
}

int factor(void) {
    int val;
    ignore_blanks();
    if (*txtpos == '-') {
        skip();
        return -factor();
    }
    else if (*txtpos == '(') {
        skip();
        val = expression();
        match(')');
    } 
    else if (strncmp((char*)txtpos, "ADC", 3) == 0) {
        txtpos += 3;
        match('(');
        expression(); 
        match(')');
        val = ADC_Read();
    }
    else if (isalpha(*txtpos)) {
        int index = toupper(*txtpos) - 'A';
        skip();
        val = variables[index];
    } 
    else {
        val = number();
    }
    return val;
}

int term(void) {
    int val = factor();
    ignore_blanks();
    while (*txtpos == '*' || *txtpos == '/') {
        if (*txtpos == '*') { skip(); val *= factor(); }
        else if (*txtpos == '/') { skip(); int d = factor(); if (d==0) error("Div0"); val /= d; }
        ignore_blanks();
    }
    return val;
}

int expression(void) {
    int val = term();
    ignore_blanks();
    while (*txtpos == '+' || *txtpos == '-') {
        if (*txtpos == '+') { skip(); val += term(); }
        else if (*txtpos == '-') { skip(); val -= term(); }
        ignore_blanks();
    }
    return val;
}

int condition(void) {
    int val = expression();
    ignore_blanks();
    if (strncmp((char*)txtpos, "<=", 2) == 0) { txtpos+=2; return val <= expression(); }
    if (strncmp((char*)txtpos, ">=", 2) == 0) { txtpos+=2; return val >= expression(); }
    if (strncmp((char*)txtpos, "<>", 2) == 0) { txtpos+=2; return val != expression(); }
    if (*txtpos == '<') { skip(); return val < expression(); }
    if (*txtpos == '>') { skip(); return val > expression(); }
    if (*txtpos == '=') { skip(); return val == expression(); }
    return val;
}

unsigned char *find_line(int line_num) {
    unsigned char *p = program;
    while (*p) {
        int current_line = p[0] | (p[1] << 8);
        if (current_line == line_num) return p;
        if (current_line > line_num) return NULL;
        p += 2;
        while (*p++);
    }
    return NULL;
}

void basic_line_insert(int line_num, char *line_str) {
    unsigned char *p = program;
    unsigned char *next_p;
    while (*p) {
        int current_line = p[0] | (p[1] << 8);
        if (current_line >= line_num) break;
        p += 2;
        while (*p++);
    }
    if (*p) {
        int current_line = p[0] | (p[1] << 8);
        if (current_line == line_num) {
            next_p = p + 2;
            while (*next_p++);
            int len_rest = PROG_SIZE - (next_p - program);
            memmove(p, next_p, len_rest);
        }
    }
    int len = strlen(line_str);
    if (len > 0) {
        unsigned char *end = program;
        while(*end) { end += 2; while(*end++); }
        if ((end - program) + len + 3 >= PROG_SIZE) { printf("Full\r\n"); return; }
        memmove(p + len + 3, p, (end - p) + 1);
        p[0] = line_num & 0xFF;
        p[1] = (line_num >> 8) & 0xFF;
        strcpy((char*)p + 2, line_str);
    }
}

void execute_statement(void) {
    ignore_blanks();
    if (strncmp((char*)txtpos, "PRINT", 5) == 0) {
        txtpos += 5;
        int newline = 1;
        while(1) {
            ignore_blanks();
            if (*txtpos == '"') {
                skip();
                while (*txtpos != '"' && *txtpos) printf("%c", *txtpos++);
                if (*txtpos == '"') skip();
                newline = 1;
            } else if (*txtpos == ';' || *txtpos == ',') {
                skip(); 
                newline = 0; 
                continue; 
            } else if (*txtpos == 0 || *txtpos == ':') {
                break;
            } else {
                printf("%d", expression());
                newline = 1;
            }
        }
        if (newline) printf("\r\n");
    }
    else if (strncmp((char*)txtpos, "LED", 3) == 0) {
        txtpos += 3;
        LED_Set(expression());
    }
    else if (strncmp((char*)txtpos, "WAIT", 4) == 0) {
        txtpos += 4;
        int ms = expression();
        for(int i=0; i<ms; i++) {
            Delay_Ms(1);
            check_break();
        }
    }
    else if (strncmp((char*)txtpos, "CLS", 3) == 0) {
        txtpos += 3;
        printf("\x1b[2J\x1b[H");
    }
    else if (strncmp((char*)txtpos, "GOTO", 4) == 0) {
        txtpos += 4;
        int line_num = expression();
        unsigned char *p = find_line(line_num);
        if (p) { txtpos = p + 2; return; }
        else error("Line?");
    }
    else if (strncmp((char*)txtpos, "IF", 2) == 0) {
        txtpos += 2;
        int cond = condition();
        ignore_blanks();
        if (strncmp((char*)txtpos, "THEN", 4) == 0) txtpos += 4;
        if (cond) execute_statement();
        else while (*txtpos) txtpos++;
    }
    else if (strncmp((char*)txtpos, "LIST", 4) == 0) {
        unsigned char *p = program;
        while (*p) {
            printf("%d %s\r\n", p[0] | (p[1] << 8), p + 2);
            p += 2; while (*p++);
            check_break();
        }
    }
    else if (strncmp((char*)txtpos, "RUN", 3) == 0) { }
    else if (strncmp((char*)txtpos, "NEW", 3) == 0) {
        memset(program, 0, PROG_SIZE);
        printf("OK\r\n");
    }
    else if (isalpha(*txtpos)) {
        int index = toupper(*txtpos) - 'A';
        txtpos++;
        ignore_blanks();
        if (*txtpos == '=') { skip(); variables[index] = expression(); }
        else error("SynErr");
    }
}

void run_program(void) {
    unsigned char *p = program;
    while (*p) {
        unsigned char *next_line = p + 2;
        while (*next_line++);
        txtpos = p + 2;
        if (setjmp(error_jmp) == 0) execute_statement();
        else return;
        check_break();
        if (txtpos >= program && txtpos < program + PROG_SIZE) {
             if (*txtpos == 0 && next_line > p) p = next_line;
             else p = txtpos - 2;
        } else break;
    }
}

int main(void)
{
    char input_buf[RX_BUF_SIZE];
    int buf_idx = 0;

    Hardware_Init();
    printf("\r\nCH32V006 Basic v1.4 (Final)\r\n> ");

    while(1)
    {
        char c = Serial_ReadChar();
        if (c >= ' ' && c <= '~') printf("%c", c);
        
        if (c == '\r') {
            printf("\r\n");
            input_buf[buf_idx] = 0;
            if (buf_idx > 0) {
                char *ptr = input_buf;
                int line_num = 0;
                if (isdigit(*ptr)) {
                    while(isdigit(*ptr)) { line_num = line_num * 10 + (*ptr - '0'); ptr++; }
                    ignore_blanks();
                    basic_line_insert(line_num, ptr + (*ptr == ' ' ? 1 : 0));
                } else {
                    for(int i=0; i<strlen(input_buf); i++) input_buf[i] = toupper(input_buf[i]);
                    if (strcmp(input_buf, "RUN") == 0) run_program();
                    else if (strcmp(input_buf, "LIST") == 0) { txtpos=(unsigned char*)"LIST"; execute_statement(); }
                    else if (strcmp(input_buf, "NEW") == 0) { memset(program,0,PROG_SIZE); printf("OK\r\n"); }
                    else if (strcmp(input_buf, "CLS") == 0) { printf("\x1b[2J\x1b[H"); }
                    else { txtpos = (unsigned char*)input_buf; if (setjmp(error_jmp) == 0) { execute_statement(); printf("OK\r\n"); } }
                }
            }
            buf_idx = 0;
            printf("> ");
        } 
        else if (c == 8 || c == 127) {
            if (buf_idx > 0) { buf_idx--; printf("\b \b"); }
        }
        else if (buf_idx < RX_BUF_SIZE - 1 && c >= ' ') {
            input_buf[buf_idx++] = c;
        }
        else if (c == 3) {
            printf("^C\r\n> ");
            buf_idx = 0;
        }
    }
}